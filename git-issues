#!/usr/bin/env python
# coding: utf-8

# git-issues, version 0.5
#
# by John Wiegley <johnw@newartisans.com>
# and github.com contributors

# TODO: (until I can add these bugs to the repo itself!)
#
# 1. use utf-8 throughout
# 2. <obsolete>
# 3. use UTC throughout
# 4. move class Issue values
#    to flexible tag LISTS more like class IssueSet
#    but more flexible

import platform

import os
import os.path
from shutil import copy
from sys import argv
import sys
import re
import optparse
import tempfile
import cPickle
import textwrap
from datetime import datetime
import unicodedata
import xml.dom.minidom
import unicodedata
from hashlib import sha1

try:
    import gitshelve
except ImportError as error:
    print "You don't have module {0} installed".format(error.message[16:])
import pdb
import inspect
from pprint import pprint
import itertools

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO



# You may wonder what dirtiness means below.  Here's the deal:
#
# An object is "self-dirty" if it itself has been changed, but possibly none
# of its children.  An object is "dirty" if its children have been changed,
# but possibly not itself.  Any dirtiness is cause for rewriting the object
# cache; only self-dirtiness of specific objects will cause the repository to
# be updated.
class Person:
    """A Person...  etc."""
    def __init__(self, name, email):
        self.name = name
        self.email = email

    def __unicode__(self):
        return u"%s <%s>" % (self.name, self.email)

    def __str__(self):
        return self.__unicode__()


class Comment:
    """A Comment...  etc."""
    def __init__(self, issue, author, comment, created=None):
        self.name = None
        self.issue = issue
        self.author = author
        self.commentText = comment
        if created:
            self.created = created
        else:
            self.created = datetime.utcnow().isoformat()[:15]
        self.modified = None
        #self.self_dirty = True  # beware _ and .
        self.dirty = False
        self.attachments = []   # records filename and blob
        #print "issue.name ", issue.name
        #print "issue.get_name() ", issue.get_name()
        self.issue.comments[issue.name] = self  # register into issue

    #def mark_dirty(self):
    def mark_dirty(self):
        self.dirty = True
        self.modified = datetime.utcnow().isoformat()[:15]
        #self.self_dirty = True
        #self.issue.mark_dirty(self_dirty=False) # necessarily?
        self.issue.mark_dirty()

    def __getstate__(self):
        odict = self.__dict__.copy()  # copy the dict since we change it
        del odict['dirty']       # remove self dirty flag from copy
        return odict

    def __setstate__(self, dict):
        self.__dict__.update(dict)    # update attributes
        #self.self_dirty = False # necessarily?

    def __getitem__(self, key): return self.data[key]

class Issue(object):
    """An Issue ...  etc."""
    def __init__(self, issueSet, author, title,
                 summary=None,
                 description=None,
                 reporters=[],
                 owners=[],
                 assigned=None,
                 carbons=[],
                 status="new",
                 resolution=None,
                 issue_type="defect",
                 components=[],
                 version=None,
                 milestone=None,
                 severity="major",
                 priority="medium",
                 tags=[]):
        self.issueSet = issueSet
        self.name = None

        # fields
        self.author = author
        self.title = title
        self.summary = summary
        self.description = description
        self.reporters = reporters
        self.owners = owners
        self.assigned = assigned
        self.carbons = carbons
        self.status = status
        self.resolution = resolution
        self.components = components
        self.version = version
        self.milestone = milestone
        self.severity = severity
        self.priority = priority
        self.tags = tags

        self.issue_type = issue_type
        self.created = datetime.utcnow().isoformat()[:15]
        self.modified = None
        self.changes = {}
        self.dirty = False     # beware . and _
        #self.self_dirty = True # beware _ and .
        self.comments = {}     # commentSet

        #fields = ["author", "title", "summary",
        #          "description", "reporters", "owners", "assigned",
        #          "carbons", "components",
        #          "version", "milestone", "severity", "priority", 
        #          "tags", "modified"] # also resolution, status, issue_type

        #for field in fields:
        #    def method(field, value):
        #        self.note_change(field, getattr(self, field), value)
        #        setattr(self, field, value)
        #    setattr(self, "set_" + field, method)

    #def mark_dirty(self, self_dirty):
    def mark_dirty(self):
        self.dirty = True
        if self_dirty:
            self.self_dirty = True
        self.modified = datetime.utcnow().isoformat()[:15]
        self.issueSet.mark_dirty(self_dirty=False) # necessarily?
        #self.issueSet.mark_dirty()

    def get_name(self):
        assert False

    def note_change(self, field, before, after):
        #if field in self.changes:
        #    data = self.changes[field]
        #    data[1] = after
        #else:
        #    data = [before, after]
        data = self.changes.get(field.lower(), [before, None])
        data[1] = after
        self.changes[field.lower()] = data

    def set_author(self, author):
        self.note_change('author', self.author, author)
        self.author = author

    def set_title(self, title):
        self.note_change('title', self.title, title)
        self.title = title

    def set_summary(self, summary):
        self.note_change('summary', self.summary, summary)
        self.summary = summary

    def set_description(self, description):
        self.note_change('description', self.description, description)
        self.description = description

    def set_reporters(self, reporters):
        self.note_change('reporters', self.reporters, reporters)
        self.reporters = reporters

    def set_owners(self, owners):
        self.note_change('owners', self.owners, owners)
        self.owners = owners

    def set_assigned(self, assigned):
        self.note_change('assigned', self.assigned, assigned)
        self.assigned = assigned

    def set_carbons(self, carbons):
        self.note_change('carbons', self.carbons, carbons)
        self.carbons = carbons

    def set_status(self, status):
        self.note_change('status', self.status, status)
        self.status = status

    def set_resolution(self, resolution):
        self.note_change('resolution', self.resolution, resolution)
        self.resolution = resolution

    def set_issue_type(self, issue_type):
        self.note_change('type', self.issue_type, issue_type)
        self.issue_type = issue_type

    def set_components(self, components):
        self.note_change('components', self.components, components)
        self.components = components

    def set_version(self, version):
        self.note_change('version', self.version, version)
        self.version = version

    def set_milestone(self, milestone):
        self.note_change('milestone', self.milestone, milestone)
        self.milestone = milestone

    def set_severity(self, severity):
        self.note_change('severity', self.severity, severity)
        self.severity = severity

    def set_priority(self, priority):
        self.note_change('priority', self.priority, priority)
        self.priority = priority

    def set_tags(self, tags):
        self.note_change('tags', self.tags, tags)
        self.tags = tags

    def __getitem__(self, key): return self.data[key]

    def __getstate__(self):
        odict = self.__dict__.copy()  # copy the dict since we change it
        del odict['changes']          # remove change log from copy
        del odict['dirty']            # remove dirty flag from copy
        #del odict['self_dirty']       # remove self dirty flag from copy
        return odict

    def __setstate__(self, dict):
        self.__dict__.update(dict)    # update attributes
        self.changes = {}
        self.dirty = True
        #self.self_dirty = False

    def numComments(self): # non-comments in keys
        return len(self.comments.keys())

    def commentFromRelativeIndex(self, id):
        try:
            matchIindex = int(id) - 1
            if matchIindex > numComments:
                return None
        except:
            return None
        cindex = 0
        for key in self.comments.keys():
            if matchIindex == cindex:
                return self.comment[key]
            cindex += 1
        return None


class IssueSet:
    """An IssueSet refers to a group of issues.  There is always at least one
    IssueSet that refers to all of the issues which exist in a repository.
    Other IssueSet's can be generated from that one as "views" or queries into
    that data.

    In essence, it contains both a set of Issues which can be looked up by
    their unique identifier, and also certain global definition, like the
    allowable components, etc."""
    def __init__(self, shelf):
        self.shelf = shelf
        self.statuses = []
        self.resolutions = []
        self.issue_types = []
        self.components = []
        self.versions = []
        self.milestones = []
        self.severities = []
        self.priorities = []
        self.dirty = False
        #self.self_dirty = True
        self.cache_version = cache_version
        self.created = datetime.utcnow().isoformat()[:15]
        self.modified = None

    #def mark_dirty(self, self_dirty_passed):
    def mark_dirty(self):
        self.dirty = True
        #if self_dirty_passed:
        self.modified = datetime.utcnow().isoformat()[:15]
            #self.self_dirty = True
        self.shelf.dirty = True

    def current_author(self):
        assert False

    def allocate_issue(self, title):
        assert False

    def new_issue(self, title):
        issue = self.allocate_issue(title)
        self.add_issue(issue)
        return issue

    def new_comment(self, issue, text):
        comment = self.allocate_comment(issue, text)
        self.add_comment(comment)
        return comment

    def comment_path(self, comment):
        # we don't need obsessively long filenames
        #return "%s/%s/comment_%s_%s_%s.xml" % \ # too much
        clean = lambda x: x.replace('/', '')
        name = clean(comment.issue.name) # issue.get_name()?
        return "%s/%s/comment_%s.xml" % \
            (name[:2],
             name[2:],
             comment.created)

    def issue_path(self, issue):
        name = issue.get_name()
        return '%s/%s/issue.xml' % (name[:2], name[2:])

    def renew_issue(self, issue):
        self.shelf[self.issue_path(issue)] = issue

    def add_issue(self, issue):
        self.shelf[self.issue_path(issue)] = issue
        #self.mark_dirty(self_dirty=False) # subobject
        self.mark_dirty()

    def add_comment(self, comment):
        self.shelf[self.comment_path(comment)] = comment
        #self.mark_dirty(self_dirty=False) # subobject
        self.mark_dirty()

    def get_all_comments(self, localIssueName):
        return self.shelf[localIssueName].comments

    def get_comment(self, id_or_ending_name, localIssueName):
        #print "get_comment id ", id_or_ending_name
        #print "get_comment localIssueName ", localIssueName
        localIssue = self.shelf[localIssueName]
        comment = None
        try:
            cid = int(id_or_ending_name) - 1
            #cid = self.relativeIndex(id_or_ending_name)
            if cid >= 0 and cid < len(localIssue.comments.keys()):
                #print "aha ", localIssueName
                #localIssue.comments.keys()[cid])
                #comment = self[localIssueName].comments[cid] # except here
                c = localIssue.comments.keys()[cid]
                cindex = 0
                for uni in localIssue.comments.iteritems():
                    namec = uni[0]
                    lookc = uni[1]
                    if "issue.xml" in namec: # check for non-comment comment
                        continue
                    for item in issueSet.shelf.keys():
                        if namec in item:
                            comment = lookc
                #print "c ", c
                #pprint(localIssue.comments)
                #print "co ", comment
        except:
            #print "here 333"
            def getCommentId(x):
                if not 'comment_' in x:
                    return ""
                x = x.split('comment_')[1]
                #x = x.split('_')[0]
                return x
            clean = lambda x: getCommentId(x)
            matching = [(clean(key), key) for key in self.shelf.iterkeys()
                        if clean(key).endswith(id_or_ending_name) and
                        not "issue.xml" in clean(key)]
            matchSize = len(matching)
            #print "matchSize 306 " , matchSize
            if matchSize == 0:
                pass
            elif matchSize == 1:
                #print "match " + str(matching[0][1])
                #print "get_tree "
                #pprint(self.shelf[matching[0][1]])
                #buf = StringIO()
                #pprint(self.shelf.dump_objects(buf))
                #buf.close()
                #print buf
                #pprint(self.shelf.dump_objects(buf))
                #
                # the hard way!
                #
                #print "ok1 "
                # size is already calculated from contents
                #size = self.shelf.git('cat-file', "-s", branchfile+"\0")
                #print "ok2 "
                branchFileName = self.branch+":"+matching[0][1]
                contents = self.shelf.git('cat-file', "-p", branchFileName)
                #print "contents", contents
                contents += "\n" # found it
                #print "ok3 "
                doc = xml.dom.minidom.parseString(contents)
                comment = XmlCommentRipper.rip(doc.firstChild, self.shelf[localIssueName])
                comment.__class__ = GitComment
                comment.issue = localIssueName
                #print "ok4 "
                #print "len(localIssueName) ", len(localIssueName)
                #print "localIssueName[:-10] ", localIssueName[:-10]
                #print "len(localIssueName[:-10]) ", len(localIssueName[:-10])
                ##comment.issueSet = self
                ## -10 removes /issue.xml
                #comment.name = localIssueName[:-10]+"/comment_"+matching[0][0]
                #print vars(comment)
                #print "comment.name ", comment.name
                #print "id_or_ending_name ", id_or_ending_name
                self.shelf[localIssueName].comments[id_or_ending_name] = comment
                #comment = "good" # placeholder
                #comment = XmlCommentRipper.rip(doc.firstChild, self.shelf[localIssueName])
                #pprint(self.shelf.git('ls-tree', matching[0][1], 'issues'))
                #val = githash(contents)
                #print val
                #sys.exit(0)
                #comment = #object_from_string(contents)
                #comment = XmlReader.readString(contents)
                doc.unlink()
            else:
                print ("Ambiguous matches:\n" +
                       '\t\n'.join(a[0] for a in matching))
        if not comment:
            raise Exception(
                "There is no comment matching the identifier '%s'.\n" %
                id_or_ending_name)
        return comment

    #def get_comment(self, uni):
    #    for item in issueSet.shelf.iteritems():
    #        i = self.get_issue(uni)
    #        target = i.created.isoformat().format("comment_%s.xml")
    #        if target in item:
    #            return target
    #    raise Exception(
    #        "There is no comment matching the identifier '%s'.\n" % uni )
    #    return

    def numIssues(self): # non-comments in keys
        iindex = 0
        for key in self.shelf.iterkeys():
            if "comment_" in key:
                continue
            iindex += 1
        return iindex

    def relativeIndex(self, idx_or_partial_hash):
        clean = lambda x: x.replace('issue.xml', '').replace('/', '')
        matchIindex = -1
        try:
            matchIindex = int(idx_or_partial_hash) - 1
        except:
            pass
        iindex = 0
        numIss = self.numIssues()
        #print numIss
        for key in self.shelf.iterkeys():
            c = clean(key)
            if "comment_" in c:
                continue
            #if c.startswith(idx_or_partial_hash) or matchIindex == iindex:
            #print c
            if matchIindex > 1 and matchIindex < numIss and matchIindex == iindex:
                #print "ri1 ", iindex
                return iindex + 1
            elif matchIindex > 1 and matchIindex > numIss and c.startswith(idx_or_partial_hash):
                # numeric matchIindex but too high so try startswith
                return iindex + 1
            elif matchIindex < 1 and c.startswith(idx_or_partial_hash):
                #print "ri2 ", iindex
                return iindex + 1
            iindex += 1
        #print "m", matchIindex
        #print "ii", iindex
        #print "idxpa", idx_or_partial_hash
        if int(matchIindex) >= int(iindex):
            return -1
        else:
            return idx_or_partial_hash

    def issueFromRelativeIndex(self, idx):
        issue = None
        try:
            matchIindex = int(idx) - 1
        except:
            return issue
        iindex = 0
        #numIss = self.numIssues()
        clean = lambda x: x.replace('issue.xml', '').replace('/', '')
        for key in self.shelf.iterkeys():
            c = clean(key)
            if "comment_" in c:
                continue
            if matchIindex == iindex:
                return self.shelf[key]
            iindex += 1
        return issue

    def __getitem__(self, idx_or_partial_hash):
        clean = lambda x: x.replace('issue.xml', '').replace('/', '')
        theissue = None
        numIss = self.numIssues()
        # check early for comparison
        matching = [(clean(key), key) for key in self.shelf.iterkeys()
                    if clean(key).startswith(idx_or_partial_hash) and
                    not "comment_" in clean(key)]
        try:
            #print "id",idx_or_partial_hash
            idx = self.relativeIndex(idx_or_partial_hash)
            #print "i",idx
            if idx < 1:
                raise Exception
            else:
                theissue = None
                try:
                    matchIindex = int(idx) - 1
                except:
                    raise Exception
                iindex = 0
                for key in self.shelf.iterkeys():
                    c = clean(key)
                    if "comment_" in c:
                        continue
                    if matchIindex == iindex:
                        #print matchIindex
                        #print iindex
                        # found
                        #print "len",len(matching)
                        if len(matching) > 0 and matchIindex > numIss:
                            print "warn: index number used over partial ID(s):\n" + \
                                '\t\n'.join(a[0] for a in matching)
                        return self.shelf[key] # object
                    iindex += 1
                raise Exception
        except: # IndexError and others
            #print "id",idx_or_partial_hash
            matching = [(clean(key), key) for key in self.shelf.iterkeys()
                        if clean(key).startswith(idx_or_partial_hash) and
                        not "comment_" in clean(key)]
            matchSize = len(matching)
            if matchSize == 0:
                pass
            elif matchSize == 1:
                theissue = self.shelf[matching[0][1]]
            else:
                print ("Ambiguous hash matches:\n" +
                       '\t\n'.join(a[0] for a in matching))

        if not theissue:
            raise Exception(
                "Missing issue-id or index matching '%s'.\n" %
                idx_or_partial_hash)
                #"Identifier ambiguous or missing '%s'.\n" % idx_or_partial_hash)

        #print "idx ", idx
        return theissue

    def __delitem__(self, idx_or_partial_hash):
        del self.shelf[None]    # jww (2008-05-14): NYI # really?
        assert False

    def issues_cache_file(self):
        assert False

    def load_state(self):
        """Given a newly created IssueSet object as a template, see if we can
        restore the cached version of the data from disk, and then check
        whether it's still valid.  This can _greatly_ speed up subsequent list
        and show operations.

        The reason why a newly created template exists is to abstract
        DVCS-specific behavior, such as the location of the cache file.

        Thus, a typical session looks like this:

          issueSet = GitIssueSet()

          if ... looking at issues list is required ...:
              issueSet = issueSet.load_state()
              ... use the issue data ...
        """
        # don't trust the cache
        ###### TEST
        ##cache_file = ""
        #cache_file = self.issues_cache_file()
        ##print cache_file
        ##sys.exit(0)
        #if os.path.isfile(cache_file):
        #    #cachedIssueSet = None
        #    if options.verbose:
        #        sys.stdout.write("Loading cache: ")
        #        sys.stdout.flush()
        #    try:
        #        fd = open(cache_file, 'rb')
        #    except:
        #        print "Error opening cache file: %s" % cache_file
        #        sys.exit(1)
        #    try:
        #        cachedIssueSet = cPickle.load(fd)
        #    except:
        #        print "Error loading cache file: %s" % cache_file
        #        sys.exit(1)
        #    fd.close()
        #    print "ok"
        #    #if cachedIssueSet and cachedIssueSet.cache_version == self.cache_version:
        #    #    if options.verbose:
        #    #        print "Cache ok version: %s" % self.cache_version
        #    #    return cachedIssueSet

        #if options.verbose:
        #    print "Cache invalid: %s" % cache_file

        # We can't use or rely on the cache, so read all details from disk and
        # then mark the IssueSet dirty so that it gets saved back again when
        # we exit.
        self.dirty = True

        # issueItems.shelf is already instantiated ?

        ## read issues
        for item in self.shelf.keys():
            if "issue.xml" in item:
                # issues branch only # os.path.isfile(item):
                #try:
                #    fd = open(item, 'rb')
                #except:
                #    print "Error opening issue: %s" % item
                #    sys.exit(1)
                #part = item.split('/')

                #if options.verbose:
                #    print "Reading %s" % item

                #self.shelf[item] = read_object(self, fd)
                part = item.split('/')
                objname = part[0] + part[1]
                issueObj = self.shelf[item]
                issueObj.__class__ = GitIssue
                issueObj.issueSet = self
                issueObj.name = objname
                issueSet.renew_issue(issueObj)
                #fd.close()
        ## read comments
        for item in self.shelf.keys():
        #for item in self.shelf.iteritems():
            #commentName = item[0]
            #commentObj = item[1]
            if "comment_" in item:
                #print "commentName ", item
                # issues branch only # os.path.isfile(item):
                #try:
                #    fd = open(item, 'rb')
                #except:
                #    print "Error opening comment: %s" % item
                #    sys.exit(1)

                #if options.verbose:
                #    print "Reading %s" % item

                part = item.split('/')
                localIssueName=part[0]+"/"+part[1]+"/issue.xml"
                issue = self.shelf[localIssueName]
                #localuuid=part[0]+part[1]
                #mymatch=part[0]+"/"+part[1]
                mymatch = item.split('comment_')[1]
                #pprint(inspect.getmembers(self))
                #pprint(self.git_directory())
                #pprint(issue.comments)
                #for x in issue.comments:
                #    print x
                #print type(self.shelf.objects)
                #commentObj = self.shelf[item]
                #print type(commentObj)
                try:
                    #print "gc1"
                    commentObj = self.get_comment(myMatch, localIssueName)
                    #print "commentObj ", commentObj
                    #print "myMatch ", myMatch
                    commentObj.name = myMatch
                    commentObj.__class__ = GitComment
                    commentObj.issue = issue
                    #print "commentObj ", commentObj
                    commentObj.issue.comments[myMatch] = commentObj # register into issue
                except:
                    pass
                # keep running if we fail to get an expected comment

                # need the doc, have to do it in get_comment!
                #self.shelf[localIssueName].comments[mymatch] = XmlCommentRipper.rip(doc.firstChild, self.shelf[localIssueName])
                #
                #commentObj = self.shelf.objects[part[0]][part[1]][part[2]].deserialize_data()
                #commentObj.__class__ = GitComment
                #pprint(inspect.getmembers(commentObj))
                #doc = xml.dom.minidom.parseString(self.shelf[item].get_data())
                #print type(object_from_string(commentObj))
                #pprint(inspect.getmembers(commentObj))
                #sys.exit(1)
                #pprint(commentObj['__book__'])
                #doc = commentObj.get(item)
                #c = xml.dom.minidom.parseString(doc)
                #commentObj = self.shelf.readString(item)
                #commentObj = self.shelf.(self.shelf, item)
                #print type(commentObj.read(item))
                #for x in commentObj:
                #    print x
                #commentObj.name = item
                #commentObj.shelf = self.shelf
                #print vars(commentObj)
                #pprint(issue.comments)
                #####def __init__(self, issue, author, comment, created=None):
                #pprint(commentObj)
                #commentObj.__class__ = GitComment
                #commentObj = self.shelf.objects[part[0]]#( self.shelf[item] )
                #print vars(self.shelf.objects[part[0]])
                #print vars(commentObj)
                # object_from_string
                #print part[2]
                #print self.shelf[part[2]] 
                #doc = XmlReader.readString( self.shelf[item] )
                #print pprint(self.shelf[item].comments)#][__book__])
                #commentObj = object_from_string( self.shelf[item] )
                #print type(commentObj)
                #print part[2]
                #self.shelf[localIssueName].comments[item] = XmlCommentRipper.rip(doc.firstChild, self.shelf[localIssueName]) 
                #commentObj = XmlCommentRipper.rip(doc.firstChild, issue) 
                #commentObj.__class__ = GitComment
                #issue.comments[localIssueName] = commentObj # register into issue
                #issue.comments[localIssueName] = commentObj # register into issue
                #for x in issue.comments:
                #    print issue.comments[x]
                #doc.unlink()
                #fd.close()
        return self
        #except: # IndexError

    #def load_sort(self):
        #if options.title:
        #    self.sort()
        #if options.id:
        #if options.created:
        #if options.time:
        #if options.reverse:

    def save_state(self):
        """Write an IssueSet to disk in object form, for fast loading on the
        next iteration.  This is only done if there are actual changes to
        write."""

        #self.shelf.commit(str(datetime.utcnow().isoformat()[:15]))
        self.shelf.close()

        cache_file = self.issues_cache_file()
        cache_file_dir = os.path.dirname(cache_file)

        if not os.path.isdir(cache_file_dir):
            os.makedirs(cache_file_dir)

        #if not self.dirty:
        #    return

        if not os.path.isfile(cache_file):
            fd = open(cache_file, 'wb')
            try:
                cPickle.dump(issueSet, fd)
            finally:
                fd.close()
    
            self.dirty = False

class XmlReader:
    """An XmlReader...  etc."""
    def read(cls, fd):
        doc = xml.dom.minidom.parse(fd)
        data = XmlRipper.rip(doc.firstChild)
        doc.unlink()
        return data

    read = classmethod(read)

    def readString(cls, data):
        # 123 debug
        #print data
        doc = xml.dom.minidom.parseString(data)
        data = XmlRipper.rip(doc.firstChild)
        doc.unlink()
        return data

    readString = classmethod(readString)


class XmlStringRipper:
    """An XmlStringRipper...  etc."""
    def rip(cls, node):
        #return node.data[1:-1]
        return node.data

    rip = classmethod(rip)


class XmlListRipper:
    """An XmlListRipper...  etc."""
    def rip(cls, node):
        assert False

    rip = classmethod(rip)


class XmlDateTimeRipper:
    """An XmlDateTimeRipper...  etc."""
    def rip(cls, node):
        try: 
            s = str(node.data.replace('-', '').replace(':', ''))[:15] # improper
        except:
            #print vars(node.childNodes[0])
            #s = str(node.replace('-', '').replace(':', ''))[:15]
            s = str(node.childNodes[0].data.replace('-', '').replace(':', ''))[:15]
        return datetime.strptime(s, iso_fmt)

    rip = classmethod(rip)


class XmlPersonRipper:
    """An XmlPersonRipper...  etc."""
    def rip(cls, node):
        #person = Person(node.childNodes[1].childNodes[0].data[1:-1],
        #                node.childNodes[3].childNodes[0].data[1:-1])
        person = Person(node.childNodes[1].childNodes[0].data,
                        node.childNodes[3].childNodes[0].data)
        return person

    rip = classmethod(rip)


class XmlIssueRipper:
    """An XmlIssueRipper...  etc."""
    def rip(cls, node):
        #print XmlRipper.rip(node.childNodes[1].childNodes[1]) #####
        #pprint(vars(node))
        try:
            created = XmlDateTimeRipper.rip(node.childNodes[1].firstChild)
        except:
            created = XmlRipper.rip(node.childNodes[1].childNodes[1])
        author = XmlRipper.rip(node.childNodes[3].childNodes[1])
        title = XmlRipper.rip(node.childNodes[5].firstChild)

        issue = Issue(None, author, title)
        issue.created = created
        issue.dirty = False

        return issue

    rip = classmethod(rip)


class XmlIssueSetRipper:
    """An XmlIssueSetRipper...  etc."""
    pass


class XmlCommentRipper:
    """An XmlCommentRipper...  etc."""
    def rip(cls, node, parentIssue):
        created = XmlRipper.rip(node.childNodes[1].childNodes[1])
        author = XmlRipper.rip(node.childNodes[3].childNodes[1])
        commentText = XmlRipper.rip(node.childNodes[5].firstChild)

        #def __init__(self, issue, author, comment):
        return Comment(parentIssue, author, commentText, created=created)

    rip = classmethod(rip)


class XmlRipper:
    """An XmlRipper...  etc."""
    def rip(cls, node):
        #pprint(vars(node))
        if node.nodeType == xml.dom.minidom.Node.TEXT_NODE and node.nodeName == 'created':
            return XmlDateTimeRipper.rip(node)
        elif node.nodeType == xml.dom.minidom.Node.TEXT_NODE:
            return XmlStringRipper.rip(node)
        elif node.nodeName == 'datetime':
            return XmlDateTimeRipper.rip(node)
        elif node.nodeName == 'person':
            return XmlPersonRipper.rip(node)
        elif node.nodeName == 'list':
            return XmlListRipper.rip(node)
        elif node.nodeName == 'issue':
            return XmlIssueRipper.rip(node)
        elif node.nodeName == 'issue-set':
            return XmlIssueSetRipper.rip(node)
        elif node.nodeName == 'comment':
            pass # special handling, handled manually elsewhere
            # XmlCommentSetRipper requires a parent object when creating the comment
            #(c,a,t) = XmlCommentRipper.rip(node) and issue
        else:
            print "node.nodeType " + str(node.nodeType)
            print "node.nodeName " + node.nodeName
            assert False

    rip = classmethod(rip)


class XmlWriter:
    """An XmlWriter...  etc."""
    def write(cls, doc, no_header=False, fd=sys.stdout):
      try:
        if no_header:
            buffer = StringIO()
            buffer.write(doc.toprettyxml(indent="", encoding="utf-8"))
            fd.write(re.sub('^.+\n', '', buffer.getvalue()))
        else:
            fd.write(doc.toprettyxml(indent="", encoding="utf-8"))
        doc.unlink()
      except:
        if options.verbose:
            buffer = StringIO()
            fd.write(re.sub('^.+\n', '', buffer.getvalue()))

    write = classmethod(write)


class XmlStringBuilder:
    """An XmlStringBuilder...  etc."""
    def build(cls, data, node, doc):
        node.appendChild(doc.createTextNode(data))

    build = classmethod(build)


class XmlListBuilder:
    """An XmlListBuilder...  etc."""
    def build(cls, data, node, doc):
        element = doc.createElement("list")
        for child in data:
            XmlBuilder.build(doc, element, child)
        node.appendChild(element)

    build = classmethod(build)


class XmlDateTimeBuilder:
    """An XmlDateTimeBuilder...  etc."""
    def build(cls, data, node, doc):
        element = doc.createElement("datetime")
        datetime = str(data)
        dat = datetime.replace('/', '').replace(':', '')[0-14]
        #print dat
        try:
            datetime = dat.strftime(iso_fmt)
        except:
            pass
        element.appendChild(doc.createTextNode(datetime))
        node.appendChild(element)

    build = classmethod(build)


class XmlPersonBuilder:
    """An XmlPersonBuilder...  etc."""
    def build(cls, data, node, doc):
        person = doc.createElement("person")

        name = doc.createElement("name")
        name.appendChild(doc.createTextNode(data.name))
        person.appendChild(name)

        email = doc.createElement("email")
        email.appendChild(doc.createTextNode(data.email))
        person.appendChild(email)

        node.appendChild(person)

    build = classmethod(build)


class XmlIssueBuilder:
    """An XmlIssueBuilder...  etc."""
    def build(cls, issue, node, doc):
        issueNode = doc.createElement("issue")

        subNodeNames = [ "created", "author", "title", "summary",
                         "description",  "reporters",  "owners", "assigned",
                         "carbons", "status", "resolution", "components",
                         "version", "milestone", "severity", "priority",
                         "tags", "modified" ]

        for name in subNodeNames:
            subnode = doc.createElement(name)
            subdata = getattr(issue, name)
            XmlBuilder.build(subdata, subnode, doc)
            issueNode.appendChild(subnode)

        issue_type = doc.createElement("type")
        XmlBuilder.build(issue.issue_type, issue_type, doc)
        issueNode.appendChild(issue_type)

        node.appendChild(issueNode)

    build = classmethod(build)


class XmlCommentBuilder:
    """An XmlCommentBuilder...  etc."""
    def build(cls, comment, node, doc):
        commentNode = doc.createElement("comment")

        subNodeNames = ["created", "author", "comment"]

        for name in subNodeNames:
            subnode = doc.createElement(name)
            subdata = getattr(comment, name)
            XmlBuilder.build(subdata, subnode, doc)
            commentNode.appendChild(subnode)

        #commentReify = doc.createElement("commentText")
        #XmlBuilder.build(comment.commentText, commentReify, doc)
        #commentNode.appendChild(commentReify)

        node.appendChild(commentNode)

    build = classmethod(build)

#class XmlIssueChangesBuilder:
#    def build(cls, data, node, doc):
#        changes = doc.createElement("changes")
#        doc.appendChild(changes)
#
#        for field_name in self.changes.keys():
#            field = doc.createElement("field")
#            field.setAttribute("name", field_name)
#
#            data = self.changes[field_name]
#
#            before = doc.createElement("before")
#            XmlBuilder.build(data[0], before, doc)
#            field.appendChild(before)
#
#            after = doc.createElement("after")
#            XmlBuilder.build(data[1], after, doc)
#            field.appendChild(after)
#
#            changes.appendChild(field)
#
#        node.appendChild(changes)
#
#    build = classmethod(build)


class XmlIssueSetBuilder:
    """An XmlIssueSetBuilder...  etc."""
    def build(cls, issueSet, node, doc):
        set = doc.createElement("issue-set")

        subNodeNames = [ "created", "status", "resolutions", "components",
                         "versions", "milestones", "severities", "priorities",
                         "tags", "modified" ]

        for name in subNodeNames:
            subnode = doc.createElement(name)
            subdata = getattr(issueSet, name)
            XmlBuilder.build(subdata, subnode, doc)
            node.appendChild(subnode)

        # types is singled out because it changes names
        issue_types = doc.createElement("types")
        XmlBuilder.build(issueSet.issue_types, issue_types, doc)
        set.appendChild(issue_types)

        node.appendChild(set)

    build = classmethod(build)


class XmlBuilder:
    """An XmlBuilder...  etc."""
    def build(cls, data, node=None, doc=None):
        if data is None:
            pass
        elif isinstance(data, datetime):
            assert doc
            XmlDateTimeBuilder.build(data, node, doc)
        elif isinstance(data, Person):
            assert doc
            XmlPersonBuilder.build(data, node, doc)
        elif isinstance(data, list):
            assert doc
            XmlListBuilder.build(data, node, doc)
        elif isinstance(data, str):
            assert doc
            XmlStringBuilder.build(data, node, doc)
        elif isinstance(data, unicode):
            assert doc
            XmlStringBuilder.build(data, node, doc)
        elif isinstance(data, Issue):
            assert not doc
            doc = xml.dom.minidom.Document()
            XmlIssueBuilder.build(data, doc, doc)
        elif isinstance(data, IssueSet):
            assert not doc
            doc = xml.dom.minidom.Document()
            XmlIssueSetBuilder.build(data, doc, doc)
        elif isinstance(data, Comment):
            assert not doc
            doc = xml.dom.minidom.Document()
            try: # ignore errors for malformed comments like <comment><comment>foo</comment></comment>
                XmlCommentBuilder.build(data, doc, doc)
            except:
                pass
        else:
            print "Unknown type %s, data %s" % (type(data), data)
            assert False # comment this out to test

        return doc

    build = classmethod(build)

######################################################################


class GitIssue(Issue):
    #def __add__(self, other):
    #    return self.value + other
    #def __init__(self, x, issueSet, name):
    #    self.__dict__ = x__dict__
    #    self.issueSet = issueSet
    #    self.name = name
    #    return self
    #    Issue.__init__(self, issueSet, author, title)

    """A GitIssue...  etc."""
    def get_name(self):
        if not self.name:
            hash_func = self.issueSet.shelf.hash_blob
            name = hash_func(self.created
                             + unicode(self.author)
                             + unicode(self.title))
            self.name = name
        return self.name


class GitComment(Comment):
    """A GitComment...  etc."""
    def get_name(self):
        if not self.name:
            name = "comment_%s.xml" % self.created.isoformat()[:15]
            self.name = name
        return self.name


class xml_gitbook(gitshelve.gitbook):
    """An xml_gitbook...  etc."""
    def serialize_data(self, data):
        return object_to_string(data)

    def deserialize_data(self, data):
        return object_from_string(data)


class GitIssueSet(IssueSet):
    """This object implements all the command necessary to interact with Git
    for the purpose of storing and distributing issues."""
    def __init__(self):
        self.branch = gitshelve.git('config', 'issues.branch', ignore_errors=True)
        if '' == self.branch:
            self.branch = 'issues'
        self.GIT_DIR = None
        self.GIT_AUTHOR = None
        self.git_directory()
        self.current_author()
        IssueSet.__init__(self, gitshelve.open(branch = self.branch,
                                               book_type = xml_gitbook))

    def git_directory(self):
        if self.GIT_DIR is None:
            self.GIT_DIR = gitshelve.git('rev-parse', '--git-dir')
        return self.GIT_DIR

    def issues_cache_file(self):
        return os.path.join(self.git_directory(), "issues.cache")

    def current_author(self):
        if self.GIT_AUTHOR is None:
            self.GIT_AUTHOR = Person(gitshelve.git('config', 'user.username'),
                                     gitshelve.git('config', 'user.email'))
        return self.GIT_AUTHOR

    def allocate_issue(self, title):
        return GitIssue(self, self.current_author(), title)

    def allocate_comment(self, issue, t):
        return GitComment(issue, self.current_author(), t)

######################################################################


def format_long_text(text, indent=13):
    """Format long text"""
    if not text:
        return "<none>"

    lines = text.split('\n')

    #buffer = StringIO()
    #first = True
    #for line in lines:
    #    if not first:
    #        buffer.write("\n%s" % (" " * indent))
    #    else:
    #        first = False
    #    buffer.write(line)
    delim = "\n" + " " * indent
    return delim.join(lines)


def format_people_list(people, indent=13):
    """Format people list"""
    if not people:
        return "<no one yet>"

    #buffer = StringIO()
    #first = True
    #for person in people:
    #    if not first:
    #        buffer.write(",\n%s" % (" " * indent))
    #    else:
    #        first = False
    #    buffer.write(person)
    #
    #return buffer.getvalue()
    delim = "\n" + " " * indent
    return delim.join(lines)


def terminal_width():
    """Return terminal width."""
    width = 0
    try:
        import struct
        import fcntl
        import termios
        s = struct.pack('HHHH', 0, 0, 0, 0)
        x = fcntl.ioctl(1, termios.TIOCGWINSZ, s)
        width = struct.unpack('HHHH', x)[1]
    except: #ImportError, IOError:
        pass
    if width <= 0:
        if "COLUMNS" in os.environ:
            width = int(os.getenv("COLUMNS"))
        if width <= 0:
            width = 80
    return width

def inputFromEditor(originalText):
    fd, tempFile = tempfile.mkstemp()
    f = open(tempFile, "w")
    f.write(originalText or "")
    f.close()

    defaultEditor = "vi"
    if platform.system() == "Windows":
        defaultEditor = "notepad"
    if "VISUAL" in os.environ:
        defaultEditor = os.getenv("VISUAL")
    elif "EDITOR" in os.environ:
        defaultEditor = os.getenv("EDITOR")
    editCommand = "%s %s" % (defaultEditor, tempFile)
    if os.system(editCommand) != 0:
        os.unlink(tempFile)
        print "Error while executing %s" % editCommand
        sys.exit(1)
    contents = open(tempFile).read()
    os.unlink(tempFile)
    return contents


def slugify(value):
    """
    Normalizes string, converts to lowercase, removes non-alpha characters,
    and converts spaces to hyphens.

    From Django template/defaultfilters.py (at around line 230)
    """
    if isinstance(value, str):
        value = unicode(value)
    value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')
    value = unicode(re.sub('[^\w\s-]', '', value).strip().lower())
    return re.sub('[-\s]+', '-', value)


def write_object(obj, file_descriptor=sys.stdout):
    XmlWriter.write(XmlBuilder.build(obj), fd=file_descriptor)


def object_to_string(obj):
    buffer = StringIO()
    XmlWriter.write(XmlBuilder.build(obj), fd=buffer)
    return buffer.getvalue()


def read_object(obj, file_descriptor):
    return XmlReader.read(file_descriptor)


def object_from_string(str):
    return XmlReader.readString(str)


def githash(data):
    s=sha1()
    s.update("blob %u\0%s" % (len(data), data))
    return s.hexdigest()

######################################################################
######################################################################
######################################################################

SVMO = "" # save_verbose_message_output
saved_environ = ""
if 'SVMO' in os.environ:
    saved_environ = os.environ['SVMO']
else:
    pass

if saved_environ:
    #print saved_environ
    SVMO = saved_environ

if platform.system() == "Windows":
    resolvedLink = None
else:
    from os import readlink
    if os.path.islink(__file__):
        resolvedLink = readlink(__file__)
    else:
        resolvedLink = None

    if resolvedLink and resolvedLink[0] != "/":
        resolvedLink = os.path.join(os.path.dirname(__file__), resolvedLink)
    if resolvedLink:
        SVMO += "Symlink found, using %s instead\n" % \
            resolvedLink
        os.environ['SVMO'] = SVMO
        # "pre-exec 1"
        os.execv(resolvedLink, [resolvedLink] + argv[1:])
        assert "This should never be called" and False

path = os.getcwd()
iso_fmt = "%Y%m%dT%H%M%S"
options = None
cache_version = 11

if ".gitissues" not in __file__:
    while not os.path.exists(os.path.join(path, ".gitissues")):
        path, extra = os.path.split(path)
        if not extra:
            break
    issuesExec = os.path.join(path, ".gitissues/git-issues")
    if os.path.exists(issuesExec) and __file__ is not issuesExec and 'SVMO' not in os.environ:
        # and not SVME in os.environ = prevents execv if repo copy is a symbolic link to a ~/bin copy
        SVMO += "git-issues repo used %s, not %s\n" % \
                (issuesExec, __file__)
        os.environ['SVMO'] = SVMO
        # "pre-exec 2", assumes this is a good executable or returns
        #     OSERROR: [Errno 8] Exec format error
        os.execv(issuesExec, [issuesExec] + argv[1:])
        assert "This should never be called" and False

description = """
    Usage: git-issues [options] <command> [command-options]

    Issue identifiers can be given as index number or partial ID
    Defaults to index number over partial ID

    Commands:
    init        Copies git-issues to .gitissues beside .git
    list        Lists issues for this repository
    new         Creates a new issue for this repository
    show/dump   Shows the given issue
    change      Change options for the given issue
    edit        edit options for the given issue in text editor
    comment     Add a comment to the given issue
    close       Close the given issue
    objects     git ls-tree -r
    shelf       pprint(issueSet.shelf)
"""

parser = optparse.OptionParser(usage=description)
parser.add_option("-v", "--verbose",
                  action="store_true",
                  dest="verbose",
                  default=False,
                  help="verbose output")

parser.add_option("--print-new-issues",
                  action="store_true",
                  dest="printNewIssues",
                  default=False,
                  help="prints out a formatted string with the bug summary " +
                  "and id. Usuful for in editor usage.")

parser.add_option("--filter-status",
                  dest="filterStatus",
                  default="closed",
                  help="do not print a issue if it is in one of " +
"the stati specified (column separated) by this option.")

parser.add_option("--filter-tags",
                  dest="filterTags",
                  default="",
                  help="prints only the issues with one of the following " +
                  "tags (column separated) associated to it.")

parser.add_option("-l", "--title",
                  action="store_true",
                  dest="title",
                  default=False,
                  help="title order")

parser.add_option("-i", "--id",
                  action="store_true",
                  dest="id",
                  default=False,
                  help="id order")

parser.add_option("-c", "--created",
                  action="store_true",
                  dest="created",
                  default=False,
                  help="created time order")

parser.add_option("-t", "--time",
                  action="store_false",
                  dest="time",
                  default=True,
                  help="time modified order")

parser.add_option("-r", "--reverse",
                  action="store_true",
                  dest="reverse",
                  default=False,
                  help="reverse order")

parser.add_option("--screen-width",
                  dest="screenWidth",
                  default=terminal_width(),
                  help="width of the terminal we are printing to.")

parser.add_option("--status",
                  dest="status",
                  default=None,
                  metavar="STATUS",
                  help="set the status of the issue to STATUS " +
                  "when creating it.")

parser.add_option("--exec-path",
                  dest="execPath",
                  action="store_true",
                  default=None,
                  help="print executables")

(options, args) = parser.parse_args()

gitshelve.verbose = options.verbose

if __name__ == '__main__':

    if options.execPath:
        print "__file__: " + __file__
        print "gitshelve.__file__: " + gitshelve.__file__
        sys.exit(0)

    if len(args) == 0:
        parser.print_help()
        sys.exit(1)

    path = os.getcwd()
    command = args[0]
    #command = os.path.basename(orig_command)
    args = args[1:]

    while not os.path.exists(os.path.join(path, ".git")):
        path, extra = os.path.split(path)
        if not extra:
            print "Unable to find a git repository. "
            print "Make sure to `git init`."
            sys.exit(1)

    if options.verbose and SVMO != "":
        # prints saved verbose message output from
        #   before the verbose option was parsed
        print SVMO
        print

    # jww (2008-05-12): Pick the appropriate IssueSet to use based on the
    # environment.
    # issueSet is our global

    #try:
    issueSet = GitIssueSet()
    issueSet = issueSet.load_state()
        #issueSet.shelf.iterItems()
        #pprint(foo)
        #print type(issueSet)
        #sys.exit(1)
    #    ###### TEST
    #    #issueSet = GitIssueSet().save_state()
    #    ##
    #    #issueSet.load_sort()
    #except KeyError as error:
    #    #GitIssueSet ?
    #    #IssueSet.__init__(self, gitshelve.open(branch = self.branch,
    #    #                                       book_type = xml_gitbook))
    #    #issueSet = GitIssueSet() #.__init__()
    #    #issueSet.save_state()    # this fails
    #    print "issueSet except"
    #    sys.exit(1)

    def verify_issues():
        """at least one issue already exists"""
        try: 
            l = len(issueSet.shelf.keys())
            if l < 1:
                raise (1)
        except: #AttributeError:
            try:
                issueSet.shelf.git('rev-parse', '--verify', issueSet.branch)
            except Exception, e:
                print "<missing branch: %s>" % issueSet.branch
            print "<no issues>";
            sys.exit(0)

    if command == "init":
        issuesdir = os.path.join(path, ".gitissues")
        rundir = os.path.dirname(__file__)
        if os.path.exists(issuesdir):
            print "git-issues helper directory %s already exists." % issuesdir
            print "Doing nothing."
            sys.exit(1)
        os.makedirs(issuesdir)
        ###########
        # though git-issues and its gitshelve.py dependency
        # must be in the path, by default save a copy to 
        # the repo for preferred use over system copy
        #
        # begin these can be removed for testing
        copy(__file__, issuesdir)                             # always
        copy(os.path.join(rundir, "gitshelve.py"), issuesdir) # always
        if os.path.isfile(os.path.join(rundir, "t_gitshelve.py")):
            copy(os.path.join(rundir, "t_gitshelve.py"), issuesdir)
        if os.path.isfile(os.path.join(rundir, "README.textiles")):
            copy(os.path.join(rundir, "README.textiles"), issuesdir)
        if os.path.isfile(os.path.join(rundir, "LICENSE")):
            copy(os.path.join(rundir, "LICENSE"), issuesdir)
        # end   these can be removed for testing
        ###########
        sys.exit(0)

    elif command == "list":
        header = "   #   Id      Title%sStatus Date   Assigned Tags"
        width = int(options.screenWidth)
        titleWidth = width - len(header)
        print header % "".join([" " for x in xrange(titleWidth)])
        print "".join(["-" for x in xrange(width)])

        iindex = 0
        foundCount = 0
        filteredStati = options.filterStatus.split(":")
        #wantedTags = dict([(tag, 1) for tag in
        #                   options.filterTags.split(":") if tag])
        wantedTags = set(options.filterTags.split(":"))

        verify_issues()
        wantedItems = dict()
        if len(args) > 0:
            wantedItems = dict([(arg, 1) for arg in args])
        clean = lambda x: x.replace('issue.xml', '').replace('/', '')
        class getOut(Exception): pass
        for item in issueSet.shelf.iteritems():
          try:
            #print "list iter " +item
            issueName = item[0]
            issueObj  = item[1]
            if "comment_" in issueName: # in the name
                continue
            iindex += 1
            #print "a "+ args[0] + " " + issueName
            issue = issueObj.get_data()
            if hasattr(issue, 'status') and issue.status in filteredStati:
                continue
            printTags = ''
            if wantedTags and not (hasattr(issue, 'tags') or issue.tags):
                continue
            if wantedTags and hasattr(issue, 'tags') and issue.tags:
                matchingTags = [tag for tag in issue.tags.split(", ")
                                if tag in wantedTags]
                if not matchingTags:
                    continue
                else:
                    printTags = matchingTags.join(", ")
            if len(wantedItems):
                found = 0
                for idx_or_partial_hash in wantedItems.keys():
                    try:
                        idx = int(idx_or_partial_hash) - 1
                        theissue = self.shelf[self.shelf.keys()[idx]]
                    except:
                        if clean(issueName).startswith(idx_or_partial_hash):
                            found = 1
                            foundCount += 1
                if not found:
                    raise getOut()

            titlePrintWidth = titleWidth + len("Title")
            formatString = "%4d  %s  %-" + \
                str(titlePrintWidth) + \
                "s %-6s %-5s  %-7s %s"
            try:
                iname = issue.name[:7]
            except TypeError:
                iname = '       '
            try:
                print formatString % \
                    (iindex, iname, unicode(issue.title.strip()),
                     issue.status,
                     issue.created and issue.created.strftime('%m/%d'),
                     unicode(issue.author)[:7], printTags)
            #except ValueError:
                #sys.exit(1)
            except:
                print formatString % \
                    (iindex, iname, issue.title, '', '','', printTags)
          except getOut:
              continue
        print
        if foundCount:
            print "  Shows %u of %u" % (foundCount, iindex)
            print

    elif command == "show" or command == "dump":
        verify_issues()
        if len(args) == 0:
            print "Usage: git-issues %s <issue-id|index> ..." % command
            sys.exit(0)
        iindex = 0
        while len(args) > 0:
            iindex += 1
            try:
                #for item in issueSet.shelf.iteritems():
                #issue = issueSet.shelf.iteritems()[args[0]]
                issue = issueSet[args[0]]
            except:
                print "Missing issue: %s" % args[0]
                args.pop(0)
                continue
            # command == "dump"
            if command == "dump":
                if len(args) > 1:
                    # try to dump a comment
                    #print "1 ",args[1]
                    #print "in ", issue.name      # tries
                    #print "gc2"
                    comment = issueSet.get_comment(args[1], issue.name)      # tries
                    if comment:
                        #print object_to_string(comment)
                        pprint(vars(comment))
                        #if options.verbose:
                        #    pprint(vars(comment))
                    args.pop(0)
                    args.pop(0)
                    continue
                # else can not dump a comment
                # dump an issue
                if hasattr(issue, 'name') and issue.name:
                    myName = issue.name
                    print "         Branch:", issueSet.shelf.branch
                    #print "           Path: %s/%s/issue.xml" % (myName[:2], myName[2:])
                    print "     Issue Name:", myName
                #print dir(issue.get_name())
                #print issue.get_name() # specifically: assert False
                #print dir(issueSet.issue_path()) # damn
                write_object(issue)
                if options.verbose:
                    pprint(vars(issue))
                args.pop(0)
                continue
            # command == "show"
            print "          Index:", issueSet.relativeIndex(args[0])
            if hasattr(issue, 'title') and issue.title:
                print "          Title:", issue.title.strip()
            if hasattr(issue, 'name') and issue.name:
                print "           Name:", issue.name
            if hasattr(issue, 'summary') and issue.summary:
                print "        Summary:", format_long_text(issue.summary)
                print
            if hasattr(issue, 'description') and issue.description:
                print "    Description:", format_long_text(
                    issue.description)
                print
            if hasattr(issue, 'author') and issue.author:
                print "         Author:", issue.author
            if hasattr(issue, 'reporters') and  issue.reporters:
                print "    Reporter(s):", format_people_list(
                    issue.reporters)
            if hasattr(issue, 'owners') and issue.owners:
                print "       Owner(s):", format_people_list(issue.owners)
            if hasattr(issue, 'assigned') and issue.assigned:
                print "       Assigned:", format_people_list(
                    issue.assigned)
            if hasattr(issue, 'carbons') and issue.carbons:
                print "             Cc:", format_people_list(issue.carbons)
            if hasattr(issue, 'issue_type') and issue.issue_type:
                print "           Type:", issue.issue_type
            if hasattr(issue, 'status') and issue.status:
                print "         Status:", issue.status
            if hasattr(issue, 'resolution') and issue.resolution:
                print "     Resolution:", issue.resolution
            if hasattr(issue, 'components') and issue.components:
                print "     Components:", issue.components
            if hasattr(issue, 'version') and issue.version:
                print "        Version:", issue.version
            if hasattr(issue, 'milestone') and issue.milestone:
                print "      Milestone:", issue.milestone
            if hasattr(issue, 'severity') and issue.severity:
                print "       Severity:", issue.severity
            if hasattr(issue, 'priority') and issue.priority:
                print "       Priority:", issue.priority
            if hasattr(issue, 'tags') and issue.tags:
                print "           Tags:", issue.tags
            if hasattr(issue, 'created'):
                print "        Created:", issue.created
            if hasattr(issue, 'modified') and issue.modified:
                print "       Modified:", issue.modified
            commentstxt = ""
            cindex = 1
            # TEST
            #print pprint(issue.comments)
            #print len(issue.comments)
            if hasattr(issue, 'comments') and len(issue.comments) > 0:
                for uni in issue.comments:
                    if "issue.xml" in uni: # check for non-comment comment
                        continue
                    for item in issueSet.shelf.keys():
                        if uni in item:
                            #print "uni "+ uni
                            #print "item "+ item
                            part = item.split('/')
                            localIssueName=part[0]+"/"+part[1]+"/issue.xml"
                            #print "localIssueName ", localIssueName
                            ##issue = self.shelf[localIssueName]
                            #print "gc3"
                            commentObj = issueSet.get_comment(uni, localIssueName)
                            commentstxt += "      Comment %s (%s): %s\n" % \
                                    (cindex, uni, commentObj.commentText.strip())
                            cindex +=1
            if commentstxt:
                print commentstxt
            print
            args.pop(0)

    elif command == "change":
        verify_issues()
        if len(args) != 3:
            print "Usage: git-issues %s <issue-id|index> <field> <value>" % command
        else:
            try:
                issue = issueSet[args[0]]
            except:
                print "Missing issue-id or index: %s" % args[0]
                sys.exit(1)

            field = args[1].lower()
            value = args[2]
            # jww (2008-05-13): Need to parse datetime, lists, and people
            try:
                changeMethod = getattr(issue, "set_" + field)
                changeMethod(value)
            except IndexError, e:
                print "Index error."
                print args
                sys.exit(1)

    elif command == "edit":
        verify_issues()
        if len(args) == 0:
            print "Usage: git-issues %s <issue-id|index> <field>" % command
            sys.exit(1)
        else:
            issue = issueSet[args[0]]
            if len(args) != 2:
                print "Usage: git-issues %s <issue-id|index> <field>" % command
                sys.exit(1)
            if not sys.stdin.isatty():
                contents = sys.stdin.read()
            else:
                cmd = args[1].lower()
                contents = inputFromEditor(getattr(issue, cmd))
            getattr(issue, "set_" + cmd)(contents)

    elif command == "close":
        verify_issues()
        if len(args) != 1:
            print "Usage: git-issues %s <issue-id|index>" % command
            sys.exit(1)
        issue = issueSet[args[0]]
        issue.set_status("closed")

    elif command == "new":
        if len(args) == 0:
            print "Usage: git-issues %s <title>" % command
        else:
            issue = issueSet.new_issue("".join([" "] + args))
            #print "".join(["-" for x in xrange(width)])
            if options.status:
                issue.set_status(options.status)
            else:
                pprint(dir(issue))
                issue.set_status("TODO")

            if options.printNewIssues or options.verbose:
                print "%s: %s (%s)" % (issue.status, issue.title.strip(),
                                       issue.name[0:7])

    elif command == "shelf":
        print "vars(issueSet.shelf)"
        pprint(vars(issueSet.shelf))
        print "x"
        pprint(issueSet.shelf.keys())
        print "zero"
        pprint(issueSet.shelf.keys()[0])
        #print issueSet.shelf['project.xml']
        #pprint(issueSet.shelf.iterkeys())
        sys.exit(0)


    elif command == "comment":
        verify_issues()
        if len(args) < 2:
            print "Usage: git-issues %s <issue-id|index> <comment>" % command
            sys.exit(1)
        issue = issueSet[args[0]] # maybe
        if len(args) == 2:
            comment = issueSet.new_comment(issue, str(args[1:]).strip())
        else:
            out = ""
            for cmt in issue.comments:
                oldcmt = issue.comments[cmt].comment.strip()
                oldcmt = textwrap.fill(oldcmt, width=70,
                                       initial_indent="# ",
                                       subsequent_indent="# ")
                out += oldcmt + "\n"

            comment_text = inputFromEditor(out)
            out = ""
            for cmt_line in comment_text.split("\n"):
                if not cmt_line.startswith("#"):
                    out += cmt_line + "\n"
            out = out.strip()
            if len(out) > 0:
                comment = issueSet.new_comment(issue, out.strip())
        if options.printNewIssues or options.verbose:
            print "### Comment(%s): %s" % (comment.name.replace('/', '')[0:7], comment.comment)

    elif command == "objects":
        #verify_issues()
        if len(args) != 0:
            print "Usage: git-issues %s" % command
            sys.exit(1)
        print "# $ git branch"
        print issueSet.shelf.git('branch')
        print "# $ git ls-tree -r %s" % issueSet.branch
        print "##"
        print "## pretty-print file contents:"
        print "## $ git cat-file -p issues:c0/0d.../issue.xml"
        print "##"
        try:
            print issueSet.shelf.git('ls-tree', '-r', issueSet.branch)
        except Exception, e:
            print "{0}".format(e)

    else:
        print "Unknown command git-issues %s" % command

    # If any of the commands made the issueSet dirty, (possibly) update the
    # repository and write out a new cache

    #try:
    issueSet.save_state()
    #except: # AttributeError:
    #    print "No issues."

    #    # AttributeError: 'NoneType' object has no attribute 'save_state'
    #    # if issuesSet doesn't exist and command didn't create one, nothing to do


# vim:ft=python:expandtab ts=4 sts=4 sw=4
